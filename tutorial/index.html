<html>
<head>
    <title>No-framework Dependency Injection with MacWire and Play Activator</title>
</head>
<body>
<div>
    <p>You've just created the Macwire + Play Framework example application! Let's explore what's inside.</p>

    <h2>Application overview</h2>

    <p>
        The main functionality of the application is to greet the user using a random greeting from an in-memory database.
        New greetings can be added by the user using a simple wbe form.
    </p>

    <p>
        The task is quite simple, and the code is probably a bit too complicated for such a simple functionality, but it
        should serve demo purposes well.
    </p>

    <p>
        There are three main parts: the <code>database</code> module, the <code>greetings</code> module and the
        frontend part, consisting of <code>controllers</code> and the html pages. We'll explore each module in detail
        in the following sections, focusing on Dependency Injection, using <code>traits</code> as modules,
        <a href="https://github.com/adamw/macwire">MacWire</a> and integration with the Play Framework.
    </p>
</div>
<div>
    <h2>The database package</h2>

    <p>
        The main trait in the <a href="#code/app/services/database" class="shortcut">database</a> package is the
        <a href="#code/app/services/database/Database.scala" class="shortcut">Database</a> trait. It defines a
        very simple interface for storing <code>String</code> key-pair values. It has a single implementation,
        <a href="#code/app/services/database/InMemoryDatabase.scala" class="shortcut">InMemoryDatabase</a>,
        which uses a <code>ConcurrentHashMap</code> for the actual storage.
    </p>

    <p>
        Note that the <code>InMemoryDatabase</code> has a dependency: an
        <a href="#code/app/services/database/AuditLogger.scala" class="shortcut">AuditLogger</a>, which simply
        prints out information about each operation. A real-world implementation could, for example, use a RDBMS for
        to implement the database, and write to a file with the current user's username for the audit.
    </p>

    <p>
        The fact that <code>InMemoryDatabase</code> is dependent on <code>AuditLogger</code> is expressed using a
        constructor parameter. And this is the main idea behind <em>Dependency Injection</em>: instead of creating a
        specific implementation of an <code>AuditLogger</code> inside the <code>InMemoryDatabase</code> class using
        <code>new</code>, we only specify that we want "some" implementation. This decouples the two classes, as we
        can now use <em>any</em> <code>AuditLogger</code> implementation, without the need to change the database.
    </p>
</div>
<div>
    <h2>The database module</h2>

    <p>
        The <a href="#code/app/services/database" class="shortcut">database</a> package also contains a
        <a href="#code/app/services/database/DatabaseModule.scala" class="shortcut">DatabaseModule</a> trait.
        In the trait, we define how to create instances of the objects from this package.
    </p>

    <p>
        In our case, and as is most common, creating the object graph is just calling <code>new</code> with
        the right parameters. Here we additionally constrain the type of the <code>database</code> value to be
        <code>Database</code>, so that clients do not see the underlying implementation type.
    </p>

    <p>
        We use <code>lazy val</code>s, so that we don't have to worry about initialization order. When using
        <code>val</code>s, objects have to be defined prior to usage. This can lead to weird
        <code>NullPointerException</code>s, hence if possible just use <code>lazy val</code>s or <code>def</code>s.
    </p>

    <p>
        In smaller applications, we could define the <em>wiring</em> (how the object graph is constructed) in one place
        for all packages, however as the codebase size grows, it can become hard to manage. Hence
    </p>

    <p>
        Note that creating such traits is entirely optional, and is not a part of the "core" <em>Dependency Injection</em>
        pattern. It is simply a way of using Scala's traits to make the code more manageable, and the pattern easier
        to use.
    </p>
</div>
<div>
    <h2>The greetings package</h2>

    <p>
        The classes in the greetings package are constructed in a similar way. The form a graph of dependencies (e.g.
        <a href="#code/app/services/greetings/RandomGreetingsService.scala" class="shortcut">RandomGreetingsService</a> depends on
        <a href="#code/app/services/greetings/RandomItemChooser.scala" class="shortcut">RandomItemChooser</a>, and the
        <a href="#code/app/services/greetings/GreetingsSaver.scala" class="shortcut">GreetingsSaver</a> depends on an
        instance of a <a href="#code/app/services/database/Database.scala" class="shortcut">Database</a>.
    </p>

    <p>
        The code is fairly simple so hopefully it is easy to understand what it does.
    </p>
</div>
<div>
    <h2>The greetings module</h2>

    <p>
        The <a href="#code/app/services/greetings/GreetingsModule.scala" class="shortcut">GreetingsModule</a> differs in two
        important ways from the <code>DatabaseModule</code>. Firstly, this module itself depends on the <code>DatabaseModule</code>,
        as we will need to access the <code>database</code> instance. Thanks to the way Scala traits work we can express
        module-level dependencies and combine several modules using trait composition.
    </p>

    <p>
        The second difference is in the way the object instances are defined: using the <code>wire</code> macro. A macro is
        a piece of Scala code which is executed at <em>compile time</em>, generating some code. The code is then type-checked
        and further compiled using standard rules. The <code>wire</code> macro is part of the MacWire library.
    </p>

    <p>
        The <code>wire</code> macro will try to generate code to create a new instance of the given class, using as parameters
        values found in the current scope. For example, <code>wire[RandomGreetingsService]</code> will expand to
        <code>new RandomGreetingsService(database, randomItemChooser)</code>. Note that this is all done at compile-time - there's
        no run-time component here! At run-time, all the JVM will see is a <code>new</code> invocation. Moreover, we get
        compile-time checking that all dependencies of a class are satisfied!
    </p>

    <p>
        Wiring using the macro can be useful when classes have several dependencies and enumerating all construction parameters
        would be tedious. Moreover, the macro can be used only for some objects, others may be created by hand or using some
        custom code.
    </p>
</div>
<div>
    <h2>The controllers</h2>

    <p>
        There are two <a href="#code/app/controllers" class="shortcut">controllers</a>. Unlike normal Play controllers,
        these are not <code>object</code>s, but <code>class</code>es, with some dependencies declared in constructors. Apart
        from that, the controllers are quite regular.
    </p>

    <p>
        The first controller, <a href="#code/app/controllers/MainController.scala" class="shortcut">MainController</a>,
        is used to get a random greeting. The second controller,
        <a href="#code/app/controllers/AddGreetingController.scala" class="shortcut">AddGreetingController</a>,
        adds a new greeting to the database.
    </p>

    <p>
        The frontend for the application is also quite standard, take a look at
        <a href="#code/app/views" class="shortcut">app/views</a> and
        <a href="#code/app/assets/javascripts/index.js" class="shortcut">assets/javascripts/index.js</a> if you are curious, but
        there's nothing Dependency Injection/MacWire-specific in these files.
    </p>
</div>
<div>
    <h2>Integrating the controllers</h2>

    <p>
        The controllers are wired using the approach we've seen before in the
        <a href="#code/app/Application.scala" class="shortcut">Application</a> object. The object depends on the two
        modules we defined earlier, hence when wiring the controllers, the necessary parameters are available.
    </p>

    <p>
        The last missing piece in the puzzle is how to tell Play how to obtain instances of the controllers? Firstly, we
        have to reference controllers in the  <a href="#code/conf/routes" class="shortcut">conf/routes</a> file with the
        <code>@</code> prefix. This will cause Play to delegate looking up instances of controllers to a special class.
    </p>

    <p>
        That special class is <a href="#code/app/Global.scala" class="shortcut">Global</a>. The method that is called by
        Play is <code>getControllerInstance</code>, passing a <code>Class</code> corresponding to the controller that
        needs to be looked up. Hence we need a map translating classes to instances.
    </p>

    <p>
        MacWire contains a utility macro to generate such a map: <code>valsByClass(someObject)</code>. The macro
        will generate (again at compile-time) a map of all the <code>val</code>s in the given object, keyed by their
        classes. Finally, we are using the <code>InstanceLookup</code> helper class from MacWire, to be able to lookup
        instances taking into account super-classes and traits (e.g., our database instance will be keyed in the map using the
        <code>InMemoryDatabase</code> class, but we are looking it up using the trait it implements, <code>Database</code>).
    </p>
</div>
<div>
    <h2>Testing</h2>

    <p>
        A very important aspect of our application is testing. One of the main benefits of <em>Dependency Injection</em>
        is the ease with which you can test components in isolation, passing in alternative implementations of any
        of the class dependencies.
    </p>

    <p>
        As an example, take a look at
        <a href="#code/test/services/greetings/GreetingsSaverSpec.scala" class="shortcut">GreetingsSaverSpec</a>.
        Here we are using a mock <code>Database</code>, using a great mocking framework Mockito. Instead of providing
        a real database implementation, we only provide a mock instance, which records what calls where made to it.
        We can then verify that the desired interactions happened.
    </p>

    <p>
        Using the trait-as-modules approach, it is also possible to integration-test whole packages, by instantiating the
        module trait. Alternative implementations can be then provided by overriding the appropriate <code>val</code>s.
    </p>
</div>
<div>
    <h2>The End</h2>

    <p>
        And that's it! We have now a simple Play application, which uses <em>Dependency Injection</em> for wiring the
        services and controllers.
    </p>

    <p>
        The whole integration layer doesn't use reflection, only type-safe, compile-time code generation. And we're only
        using plain, old Scala traits and classes, without the help of any framework.
    </p>

    <p>
        If you are interested, a couple of useful links:
    </p>

    <ul>
        <li><a href="http://www.playframework.com/documentation" target="_blank">Play Documentation</a></li>
        <li><a href="https://github.com/adamw/macwire" target="_blank">The MacWire project on GitHub</a></li>
        <li><a href="https://code.google.com/p/mockito/" target="_blank">Mockito - Simple Mocking Framework</a></li>
    </ul>
</div>
</body>
</html>
